機器人座標原點位於右側第一顆馬達的旋轉中心線上, 脊椎中心線是平行 z 軸且通過點(35, 0,0) 脊椎中心距離左邊第一個繞 z 旋轉的馬達中心為 35mm, 左邊第一顆馬達旋轉中心點座標(70, 0, 54.22)
左邊第二顆馬達繞 y 旋轉, 左邊第二顆馬中心軸其中一點為 (70, -24.7, 17.5)
左邊第三顆馬達繞 x 旋轉, 左邊第三顆馬中心軸其中一點為 (157.03, 14.64, 16.52)
左邊第四顆馬達繞 x 旋轉, 左邊第三顆馬中心軸其中一點為 (157.03, 16.28, -61.75)
左邊第五顆馬達繞 x 旋轉, 左邊第三顆馬中心軸其中一點為 (157.03, 17.92, -140.01)
且左右腳的配置對稱

from controller import Robot, Keyboard, InertialUnit, GPS
import math

# ========================
# 初始化與感測器
# ========================

robot = Robot()
timestep = int(robot.getBasicTimeStep())
keyboard = Keyboard()
keyboard.enable(timestep)

# 馬達
t1 = robot.getDevice('t1'); t2 = robot.getDevice('t2'); t3 = robot.getDevice('t3'); t4 = robot.getDevice('t4'); t5 = robot.getDevice('t5')
rt1 = robot.getDevice('rt1'); rt2 = robot.getDevice('rt2'); rt3 = robot.getDevice('rt3'); rt4 = robot.getDevice('rt4'); rt5 = robot.getDevice('rt5')
left_motors = [t1, t2, t3, t4, t5]
right_motors = [rt1, rt2, rt3, rt4, rt5]

# 感測器
t1_sensor = robot.getDevice('t1_sensor'); t2_sensor = robot.getDevice('t2_sensor'); t3_sensor = robot.getDevice('t3_sensor'); t4_sensor = robot.getDevice('t4_sensor'); t5_sensor = robot.getDevice('t5_sensor')
rt1_sensor = robot.getDevice('rt1_sensor'); rt2_sensor = robot.getDevice('rt2_sensor'); rt3_sensor = robot.getDevice('rt3_sensor'); rt4_sensor = robot.getDevice('rt4_sensor'); rt5_sensor = robot.getDevice('rt5_sensor')
left_sensors = [t1_sensor, t2_sensor, t3_sensor, t4_sensor, t5_sensor]
right_sensors = [rt1_sensor, rt2_sensor, rt3_sensor, rt4_sensor, rt5_sensor]
for sensor in left_sensors + right_sensors: sensor.enable(timestep)

# 姿態與位置感測器 (LIPM 平衡必需)
imu = robot.getDevice('imu') if robot.getDevice('imu') else None # 假設有慣性單元
if imu: imu.enable(timestep)
gps = robot.getDevice('gps') if robot.getDevice('gps') else None # 假設有GPS (用於獲取CoM位置)
if gps: gps.enable(timestep)

# ========================
# 全域變數與 LIPM 參數
# ========================

left_target_deg = [0, 0, 0, 0, 0]
right_target_deg = [0, 0, 0, 0, 0]

# --- LIPM 常數 ---
# 這些值需要根據您的機器人模型調整！
ROBOT_HEIGHT_H = 0.50  # 質心高度 (米) - 假設值
GRAVITY_G = 9.81      # 重力加速度
OMEGA_0 = math.sqrt(GRAVITY_G / ROBOT_HEIGHT_H) # LIPM 固有頻率

MOVE_TIME = 1.0
FAST_MOVE_TIME = 0.5
MARGIN = 1.1
TOLERANCE = 0.01

target_positions = [0.0] * 10
SUPPORT_FOOT = 'both' # 'left', 'right', 'both'

# ========================
# LIPM 核心函數
# ========================

def calculate_lipm_adjustment(roll_error, pitch_error, current_deg):
    """
    簡化版的 LIPM 調整：根據傾斜誤差 (roll/pitch) 來計算支撐腿的目標角度。
    由於沒有逆運動學，我們使用一個簡化的 P-Controller 比例控制來調整關鍵關節 (t2/rt2, t3/rt3)。
    
    :param roll_error: 沿 X 軸的旋轉誤差 (側傾)
    :param pitch_error: 沿 Y 軸的旋轉誤差 (俯仰)
    :param current_deg: 支撐腿當前的目標角度 (度)
    :return: 調整後的目標角度 (度)
    """
    
    # 比例增益 (需要微調)
    K_ROLL = 5.0  # 調整 t2 (Hip Roll) 的增益
    K_PITCH = 8.0 # 調整 t3 (Hip Pitch) 的增益
    
    adjusted_deg = list(current_deg)
    
    # t2/rt2 (通常是 Hip Roll): 用於平衡側傾 (Roll)
    # 假設 roll_error > 0 表示向右傾斜，需要 rt2/t2 向左或向右調整來拉回。
    # 這裡我們讓 t2/rt2 進行一個與 roll_error 成比例的反向調整
    adjusted_deg[1] -= roll_error * K_ROLL
    
    # t3/rt3 (通常是 Hip Pitch): 用於平衡俯仰 (Pitch)
    # 假設 pitch_error > 0 表示向前傾斜。
    adjusted_deg[2] -= pitch_error * K_PITCH
    
    # t5/rt5 (通常是 Ankle Pitch/Roll) 也可以加入調整來提供踝關節扭矩，這裡暫時不加。
    
    # 將角度限制在合理範圍內 (例如 ±45 度，視實際馬達限制)
    adjusted_deg = [max(-45, min(45, d)) for d in adjusted_deg]
    
    return adjusted_deg

def get_current_attitude():
    """ 獲取當前機器人的姿態 (Roll, Pitch, Yaw) """
    if imu:
        # Webots IMU: [roll, pitch, yaw]
        rpy = imu.getRollPitchYaw()
        return rpy[0], rpy[1], rpy[2]
    # 如果沒有 IMU，則返回 0
    return 0.0, 0.0, 0.0

def LIPM_balance_update(support_foot_deg):
    """
    LIPM 控制主函數：讀取當前姿態，計算支撐腳的調整角度。
    """
    roll, pitch, _ = get_current_attitude()
    
    # 我們的目標是讓 roll 和 pitch 趨近於 0 (保持直立)
    roll_error = roll - 0.0
    pitch_error = pitch - 0.0
    
    # 應用 LIPM 輔助的比例控制調整
    new_support_deg = calculate_lipm_adjustment(roll_error, pitch_error, support_foot_deg)
    
    return new_support_deg

# ========================
# 基本/姿態/單關節函數 (保持不變)
# ========================

def degrees_to_radians(deg_list): return [math.radians(d) for d in deg_list]
def update_target_positions():
    global target_positions
    target_positions = degrees_to_radians(left_target_deg) + degrees_to_radians(right_target_deg)
def get_current_positions(): return [s.getValue() for s in left_sensors + right_sensors]

def calculate_velocities(move_time):
    current = get_current_positions()
    velocities = []
    for i in range(10):
        delta = abs(target_positions[i] - current[i])
        vel = delta / move_time if delta > 1e-6 else 0.0
        velocities.append(vel * MARGIN)
    return velocities

def set_motor_targets(move_time=MOVE_TIME):
    update_target_positions()
    current = get_current_positions()
    velocities = calculate_velocities(move_time)
    for i, motor in enumerate(left_motors + right_motors):
        motor.setPosition(target_positions[i])
        motor.setVelocity(velocities[i])
    # print(f"移動到: 左腿{[round(d,1) for d in left_target_deg]}, 右腿{[round(d,1) for d in right_target_deg]} (時間: {move_time}s)")

def stop_all_motors():
    for motor in left_motors + right_motors: motor.setVelocity(0.0)

def is_arrived():
    current = get_current_positions()
    return all(abs(current[i] - target_positions[i]) < TOLERANCE for i in range(10))

def stand_pose():
    global left_target_deg, right_target_deg, SUPPORT_FOOT
    left_target_deg = [0, 0, 0, 0, 0]
    right_target_deg = [0, 0, 0, 0, 0]
    SUPPORT_FOOT = 'both'
    print("=== 強制站立：所有關節歸零 ===")

def squat_pose():
    global left_target_deg, right_target_deg, SUPPORT_FOOT
    left_target_deg = [0, 0, 55, -110, 55]
    right_target_deg = [0, 0, 55, -110, 55]
    SUPPORT_FOOT = 'both'
    print("=== 蹲姿 ===")
    
# 單關節控制
def adjust_joint(side, idx, delta):
    global SUPPORT_FOOT
    if side == 'left':
        left_target_deg[idx] += delta
        SUPPORT_FOOT = 'right' # 左腳手動控制，右腳變為支撐腳
    else:
        right_target_deg[idx] += delta
        SUPPORT_FOOT = 'left'  # 右腳手動控制，左腳變為支撐腳
        
    # 如果同時有按鍵按下，可能會導致衝突，但我們優先考慮最後按下的
    print(f"手動調整 {side} {idx+1} 關節。支撐腳: {SUPPORT_FOOT}")

def handle_key_adjust(key):
    # 鍵盤映射 (保持不變)
    if key == ord('1'): adjust_joint('left', 0, 10)
    elif key == ord('2'): adjust_joint('left', 1, 10)
    elif key == ord('3'): adjust_joint('left', 2, 10)
    elif key == ord('4'): adjust_joint('left', 3, 10)
    elif key == ord('5'): adjust_joint('left', 4, 10)
    elif key in [ord('Q'),ord('q')]: adjust_joint('left', 0, -10)
    elif key in [ord('W'),ord('w')]: adjust_joint('left', 1, -10)
    elif key in [ord('E'),ord('e')]: adjust_joint('left', 2, -10)
    elif key in [ord('R'),ord('r')]: adjust_joint('left', 3, -10)
    elif key in [ord('T'),ord('t')]: adjust_joint('left', 4, -10)
    elif key == ord('6'): adjust_joint('right', 0, 10)
    elif key == ord('7'): adjust_joint('right', 1, 10)
    elif key == ord('8'): adjust_joint('right', 2, 10)
    elif key == ord('9'): adjust_joint('right', 3, 10)
    elif key == ord('0'): adjust_joint('right', 4, 10)
    elif key in [ord('Y'),ord('y')]: adjust_joint('right', 0, -10)
    elif key in [ord('U'),ord('u')]: adjust_joint('right', 1, -10)
    elif key in [ord('I'),ord('i')]: adjust_joint('right', 2, -10)
    elif key in [ord('O'),ord('o')]: adjust_joint('right', 3, -10)
    elif key in [ord('P'),ord('p')]: adjust_joint('right', 4, -10)


# ========================
# 主迴圈
# ========================

print("\n" + "="*70)
print("          雙足機器人 LIPM 平衡輔助控制面板")
print("="*70)
print("s : 站立 (清除 SUPPORT_FOOT 狀態)")
print("k : 蹲姿")
print("1-5/qwert/6-0/yuiop : 手動調整單腿關節角度，自動啟動另一隻腳的LIPM平衡")
print("警告: 鍵盤調整時 a 序列會中斷！")
print("="*70)

moving = False
prev_manual_control = False

while robot.step(timestep) != -1:
    key = keyboard.getKey()
    
    # --- 1. 處理手動/預設按鍵 ---
    is_manual_adjust = False
    
    if key != -1:
        if key in [ord('S'), ord('s')]:
            stand_pose()
            set_motor_targets()
            moving = True
        elif key in [ord('K'), ord('k')]:
            squat_pose()
            set_motor_targets()
            moving = True
        elif key in [ord('A'), ord('a')]:
            # 這裡我們簡化處理，直接將 a 序列中斷並回到站立
            stand_pose()
            set_motor_targets()
            moving = True
            print("a 序列已被移除，請使用單關節控制。")
        else:
            handle_key_adjust(key) # 這裡會自動設置 SUPPORT_FOOT
            is_manual_adjust = True
            moving = True

    # --- 2. 執行 LIPM 平衡調整 ---
    if moving or is_manual_adjust:
        # 僅當不是雙腳支撐時才進行平衡調整
        if SUPPORT_FOOT == 'left':
            # 左腳是支撐腳，右腳是手動控制腳 (擺動腳)
            new_left_deg = LIPM_balance_update(left_target_deg)
            left_target_deg = new_left_deg
            print(f"LIPM 輔助: 左腳 (t2:{round(new_left_deg[1],1)}°, t3:{round(new_left_deg[2],1)}°)")

        elif SUPPORT_FOOT == 'right':
            # 右腳是支撐腳，左腳是手動控制腳
            new_right_deg = LIPM_balance_update(right_target_deg)
            right_target_deg = new_right_deg
            print(f"LIPM 輔助: 右腳 (rt2:{round(new_right_deg[1],1)}°, rt3:{round(new_right_deg[2],1)}°)")
            
        # 重新設置馬達目標 (包含手動調整腳和 LIPM 調整腳)
        set_motor_targets(FAST_MOVE_TIME if is_manual_adjust else MOVE_TIME)

    # --- 3. 動作完成偵測 ---
    if moving and is_arrived():
        stop_all_motors()
        moving = False
        # 只有在手動控制停止後，才讓 SUPPORT_FOOT 回到 'both' (如果需要的話)
        # 為了即時響應，我們讓它保持狀態直到按下 's' 或 'k'

    # 偵測是否從手動控制狀態切換到靜止狀態 (用於優化輸出，但這裡暫不實現複雜狀態機)