var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 電腦輔助設計與實習 \n \n 分組倉儲 demo 網站:  https://mde.tw/cad_demo \n demo 倉儲:  https://github.com/mdecycu/cad_demo \xa0 \n 課程評分: \n 學習心得報告 (60%)  - MS Teams 線上參與，6人一組每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 學習心得報告主題 : \n w3: 用什麼套件完成  5-bar Linkage Plotter  與  Openduck mini  零組件設計繪圖？  Solvespace ,  Siemens NX ,  Onshape  或其他？各有什麼優缺點？ ( plotter.7z ,  open_duck_mini.7z ) \n w7 ( 2a 採 Youtube 影片簡報 ):  5-bar Linkage Plotter  與  Openduck mini \xa0零組件設計繪製完成之後，如何切割零件? 為何要切割零件？ 如何利用  Webots  進行後續的控制系統設計與動態模擬 (Dynamic Simulation)？( plotter_project.7z ) \n w10:  Webots  是什麼？有什麼特點？ 如何進行場景模擬？ 如何用 Python 進行控制系統設計？ ( Tutorial ) \n w14:  Webots  的模型有沒有辦法用程式方法建立? 有沒有辦法直接從 CAD 套件中轉出  Webots  的場景模型？ \n w17: 如何實作一套  5-bar Linkage Plotter  與  Openduck mini ？( Disney Bipedal Robot ) \n w18: 課程總結 \n 個人與分組網站維護 (40%)  - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評 \n', 'tags': '', 'url': 'About.html'}, {'title': 'Reading', 'text': '英文資料基本閱讀能力自我查驗: \n 認不認得這  2000_words.txt ， 5000_words.txt  呢? \n', 'tags': '', 'url': 'Reading.html'}, {'title': 'CAD', 'text': '參數式零組件繪圖相關參考資料: \n AutoDesk Inventor: \n autodesk_inventor_api.7z \n SolidWorks: \n solidworks_basics.pdf \n Solidworks_ref.7z \n Siemens NX: \n nx_python_examples.pdf \n nxopen_python_ref.7z \n NXOpen_Getting_Started_2017.pdf \n NXOpen_Getting_Started_2019.pdf \n SNAP_Getting_Started_v12.pdf \n Solvespace: \n solvespace-documentation.pdf \n https://solvespace.readthedocs.io/en/latest/ \n https://solvespace.com/tutorial.pl \n https://youtu.be/vBNAIMiomls \n https://arachnoid.com/Computer_Aided_Design/index.html \n https://news.ycombinator.com/item?id=30625341 \n https://cq.cx/sketchflat.pl \n https://cq.cx/sketchflat-tutorial.p l \n sketchflat-internals.pdf \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'Design', 'text': 'Math \n 利用基因演算法解決機械設計問題: \n Length = 20 \n 平面五連桿 Plotter 設計目標是針對一組 Length cm×Length cm 的繪圖區域，尋找並最佳化五連桿機構中的三個核心設計變數：連桿 L1、連桿 L2，以及底部距離 distance。最終目的是在確保機構穩定運行的前提下，找到能使連桿尺寸最小化（即材料成本與運動慣性最低）的設計。 一、幾何參數設定 \xa0 \xa0 馬達間距 (LENGTH): 兩側連桿（L1 和 L4）的固定轉軸中心必須保持 Length cm 的水平間距。 \xa0 \xa0 繪圖區域 (W×H): 機構必須能覆蓋一個 Length cm 寬度 (W) 和 Length cm 高度 (H) 的完整矩形區域。 \xa0 \xa0 對稱性要求: 機構必須保持對稱，即 L1=L4 且 L2=L3。 二、最小化優化目標 (Objective) 設計應追求連桿總尺寸的最小化。優化目標 J 定義為： 最小化 J=1.0⋅L1+1.0⋅L2+0.5⋅distance （此權重分配旨在優先最小化連桿長度 L1 和 L2，同時適度控制機構的底部高度 distance。） 三、運動學與工程約束 (Constraints) 設計結果必須嚴格滿足以下三個工程約束，以確保筆尖 C 點在整個繪圖區域內不會遇到死點或不可達的情況。 1. 可達性與外側奇異點迴避 (L1+L2 約束) 連桿 L1 與 L2 的長度總和必須大於機構在繪圖區域最遠點（即 X=Length,Y=distance+Length）處所需的最大距離 Dmax。 這項約束保證了筆尖在最遠處不會發生連桿 L1 和 L2 完全伸直共線（外側奇異點，即 A,B,C 共線）導致的鎖死。 2. 繪圖區域穩定性 (內側奇異點迴避) 連桿 L2 的兩倍長度 (2⋅L2) 必須大於筆尖 C 點在整個 Length cm×Length cm 繪圖區域內時，點 B 到點 D 之間的最大距離 Max(DBD)Area。 更重要的是，為了考慮實際製造公差和控制誤差，必須強制加入 1.0 cm 的安全裕度 (Δ)： 2⋅L2>Max(DBD)Area+1.0 cm 這項約束保證了筆尖在任何位置都不會發生連桿 L2 和 L3 完全伸直共線（內側奇異點，即 B,C,D 共線）導致的控制失效。 3. 轉軸方向約束 (Y 座標約束) 在求解逆運動學時，連桿 L1 和 L4 的擺動點 B 點和 D 點的垂直坐標 (YB 和 YD) 必須始終大於或等於零。 這確保了機構在整個工作過程中始終處於轉軸上方（上搖桿解）的穩定配置，防止機構翻轉至下方區域。 \n redesign_ga1.py \n redesign_ga1.slvs \n 【基因演算法最終最小化尺寸設計結果】 找到**滿足約束且最小化尺寸**的設計（總尺寸 J ≈ 59.44 cm）: L1 (Link 1 & 4) = 21.79 cm L2 (Link 2 & 3) = 26.70 cm Distance (Y-bottom) = 21.89 cm --- 最終設計驗證 --- 1. 最遠點奇異點約束 (L1+L2 > D_max): 48.50 > 46.42 (滿足) 2. 繪圖區域穩定性 (2*L2 > Max(D_BD) + 1.0cm): \xa0 \xa02*L2 = 53.40 cm \xa0 \xa0Max(D_BD) + 1.0 cm = 51.60 + 1.00 = 52.60 cm \xa0 \xa0**裕度滿足 (2*L2 僅略大於所需值，實現最小化)** 3. Y 座標約束 (Y_B, Y_D >= 0): 在逆運動學中已確保 (滿足) \n \n 最小尺寸設計如下: \n 【基因演算法最終最小化尺寸設計結果】 找到**滿足約束且最小化尺寸**的設計（總尺寸 J ≈ 54.97 cm）: L1 (Link 1 & 4) = 20.00 cm L2 (Link 2 & 3) = 25.44 cm Distance (Y-bottom) = 19.04 cm --- 最終設計驗證 --- 1. 最遠點奇異點約束 (L1+L2 > D_max): 45.45 > 43.87 (滿足) 2. 繪圖區域穩定性 (2*L2 > Max(D_BD) + 1.0cm): \xa0 \xa02*L2 = 50.89 cm \xa0 \xa0Max(D_BD) + 1.0 cm = 49.63 + 1.00 = 50.63 cm \xa0 \xa0**裕度滿足 (2*L2 僅略大於所需值，實現最小化)** 3. Y 座標約束 (Y_B, Y_D >= 0): 在逆運動學中已確保 (滿足) \n \n 利用 Python + Sympy 解數學相關題目: \n taming math and physics using sympy.pdf \n sympy_documentation.pdf \n Simulation \n modeling and simulation in python.pdf \n bond_graph_modeling.pdf \n Inverse Kinematics: \n inverse_kinematics_solution_of_a_robotic_manipulator_using_python_(two_link).pdf \n inverse_kinematic_analysis_of_robot_manipulators(dissertation_2015).pdf \n Mechanical Advantage Analysis: \n /downloads/mechanical_advantage_analysis.pdf \n Webots: \n Simulation_of_a_Mobile_Manipulator_on_Webots.pdf', 'tags': '', 'url': 'Design.html'}, {'title': 'Plotter', 'text': '設計要求: \n 使用平面五連桿設計一套能夠在  20cm x 20cm  範圍中進行繪圖的畫圖機 \n 驅動: NEMA 17 步進馬達或 STS3215 系列伺服馬達 \n 首先查詢\xa0NEMA 17 步進馬達與STS3215 系列伺服馬達的規格尺寸。 \n 17 NE2: 42.3mmx42.3mmx34mm (from\xa0 https://www.sumfu.com/step/nema17 ) \n STS3215: 45.23mmx24.73mmx29mm (from  FeeTech ) \n 平面五連桿 plotter 自由度如何計算? \n 計算「平面五連桿機構（Five-bar linkage）」的自由度（Degrees of Freedom, DOF）可以使用「Gruebler-Kutzbach 方程式」來處理。 \n 平面機構的自由度 = 3(包含地面的構件數 - 1) - 2(有一個自由度的接頭數) - 有兩個自由度的接頭數 \n 因此平面五連桿的自由度 = 3(5-1) - 2(5) - 0 = 2，因此設計中的 Plotter 有兩個自由度。 \n 以下使用基因演算法進行尺寸設計: \n 五連桿機構設計最佳化：最小化連桿尺寸 本設計的目標是針對一組 20 cm × 20 cm 的繪圖區域，尋找並最佳化三個核心設計變數：連桿 L1、連桿 L2，以及底部距離 distance。最終目的是在確保機構穩定運行的前提下，找到能使連桿尺寸最小化（即材料成本與運動慣性最低）的設計。 一、幾何參數設定 A. 待最佳化設計變數： 1. L1：主連桿/驅動連桿長度（L1 = L4）。 2. L2：副連桿長度（L2 = L3）。 3. distance：機構底部距離（定義馬達中心連線到繪圖區域底邊的垂直距離）。 B. 固定參數： 1. 馬達間距 (LENGTH)：兩側連桿（L1 和 L4）的固定轉軸中心必須保持 20 cm 的水平間距。 2. 繪圖區域 (W×H)：機構必須能覆蓋一個 20 cm 寬度和 20 cm 高度的完整矩形區域。 3. 對稱性要求：機構必須保持對稱，即 L1=L4 且 L2=L3。 二、最小化優化目標 (Objective) \n 設計應追求連桿總尺寸的最小化。優化目標 J 定義為： \n 最小化 J = 1.0 * L1 + 1.0 * L2 + 0.5 * distance \n （此權重分配旨在優先最小化連桿長度 L1 和 L2，同時適度控制機構的底部高度 distance。） \n 三、運動學與工程約束 (Constraints) \n 設計結果必須嚴格滿足以下三個工程約束，以確保筆尖 C 點在整個繪圖區域內不會遇到死點或不可達的情況。 C1. 可達性與外側奇異點迴避 (L1+L2 約束) \n 連桿 L1 與 L2 的長度總和必須大於機構在繪圖區域最遠點所需的最大距離 Dmax。 \n 目的：保證筆尖在最遠處不會發生連桿 L1 和 L2 完全伸直共線（外側奇異點）導致的鎖死。 約束式：L1 + L2 > Dmax \n C2. 繪圖區域穩定性與內側奇異點迴避 \n 連桿 L2 的兩倍長度 (2 * L2) 必須大於筆尖 C 點在整個 20 cm × 20 cm 繪圖區域內時，點 B 到點 D 之間的最大距離 Max(DBD)Area。 安全裕度：必須強制加入 1.0 cm 的安全裕度 (Δ)。 目的：保證筆尖在任何位置都不會發生連桿 L2 和 L3 完全伸直共線（內側奇異點）導致的控制失效。 約束式：2 * L2 > Max(DBD)Area + 1.0 cm \n C3. 轉軸方向約束 (Y 座標約束) \n 在求解逆運動學時，連桿 L1 和 L4 的擺動點 B 點和 D 點的垂直坐標 (YB 和 YD) 必須始終大於或等於零。 \n 目的：確保機構在整個工作過程中始終處於轉軸上方（上搖桿解）的穩定配置，防止機構翻轉至下方區域。 \n 約束式：YB >= 0 且 YD >= 0 \n redesign_ga1.py \n 選用下列設計: \n A 點座標 (0, 0) 為 5-bar planar plotter 的左邊馬達位置, 其轉動角度以逆時針為正, 轉角設為 t1, 且從其右邊的水平線算起 E 點座標 (20, 0) 為右邊馬達位置, 其轉動角度也是以逆時針為正, 轉角設為 t2, 也是從其右邊的水平線算起 AB 為 link1 長度為 20, BC 為 link2 長度為 27, CD 為 link3 長度為 27, DE 為 link4 長度為 20, C 點為 plotter 擺放位置 請利用數值方法推導 def t1(cx, cy) 以及 t2(cx, cy), 其中 cx 為 plotter C 點的 x 座標, 而 cy 則為 plotter C點的 y 座標 \n \n redesign.slvs \n redesign.py \n verify_20_40.py \n redesign.7z \n redesign_simulation.py \n plotter_redesign.7z \xa0(含初步 Webots 場景) \n 修正起始角度的 Webots 場景:\xa0 plotter_redesign_w6.7z \n 利用影像辨識導引繪圖:\xa0 plotter_redesign_w7.7z \n Prompt: \n A 點座標 (0, 0) 為 5-bar planar plotter 的左邊馬達位置, 其轉動角度以逆時針為正, 轉角設為 t1, 且從其右邊的水平線算起 E 點座標 (0.2, 0) 為右邊馬達位置, 其轉動角度也是以逆時針為正, 轉角設為 t2, 也是從其右邊的水平線算起 AB 為 link1 長度為 0.2, BC 為 link2 長度為 027, CD 為 link3 長度為 0.27, DE 為 link4 長度為 0.2, C 點為 plotter 擺放位置 請利用 sympy 方法推導 def t1(cx, cy) 以及 t2(cx, cy), 其中 cx 為 plotter C 點的 x 座標, 而 cy 則為 plotter C點的 y 座標 最後結果請給出四種 solutions 的 python function 格式 \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Plotter.html'}, {'title': '自由度', 'text': '平面機構的自由度推導: 要解釋  Grübler 公式 （或稱 Kutzbach 公式）如何推導出來，需要從平面機構的運動學基本原理出發，逐步分析構件、自由度和約束的關係。以下是 Grübler 公式的推導過程，針對平面五連桿機構的自由度計算： Grübler 公式 \n 平面機構的自由度公式為： \n \\[ DOF = 3(N - 1) - 2J_1 - J_2 \\] \n 其中： \n \\(DOF\\)：機構的自由度。 \\(N\\)：構件數（包括機架）。 \\(J_1\\)：一自由度關節數（例如轉動軸或滑動軸）。 \\(J_2\\)：二自由度關節數。 推導過程 \n 推導 Grübler 公式的核心是計算機構中所有構件的總自由度，然後減去關節施加的約束，得到淨自由度。 一、單一構件的自由度 \n 在平面運動中，每個獨立的構件（不與其他構件連接）有以下自由度： 兩個平移自由度（沿 x 和 y 軸移動）。 一個旋轉自由度（繞 z 軸旋轉，平面運動不考慮其他旋轉）。 因此，每個構件的自由度為 3。 對於一個機構有 \\(N\\) 個構件（包括機架），總自由度為： \n \\[ 3N \\] 二、固定機架的影響 \n 機構通常有一個固定的構件（機架），其自由度完全被約束（即自由度為 0）。為了計算運動構件的自由度，我們從總構件數中減去機架： \n 機架數量為 1，剩餘的運動構件數為 \\(N - 1\\)。 但是，為了統一計算，我們先考慮所有構件的自由度，然後通過約束來減去自由度。 三、關節的約束 \n 關節（joint）限制了構件之間的相對運動，每個關節會減少一定的自由度： \n 單一自由度關節（例如轉動副或滑動副）：這種關節允許一個自由度（例如只允許旋轉或只允許滑動），因此約束了 2 個自由度（因為每個構件原本有 3 個自由度，關節限制了其中 2 個）。 \n 每個一自由度關節的約束數：\\(3 - 1 = 2\\)。 \n 如果有 \\(J_1\\) 個一自由度關節，總約束為：\\(2J_1\\)。 \n 兩個自由度關節（例如平面關節，允許兩個平移或一個平移加一個旋轉）：這種關節只約束 1 個自由度。 \n 每個二自由度關節的約束數：\\(3 - 2 = 1\\)。 \n 如果有 \\(J_2\\) 個二自由度關節，總約束為：\\(J_2\\)。 \n 四、總自由度計算 \n 將所有構件的自由度減去關節的約束，得到機構的總自由度： \n \\[ DOF = 3N - (2J_1 + J_2) \\] 五、考慮機架的固定 \n 機架作為一個構件，其自由度被完全約束（即 3 個自由度被移除）。因此，我們需要考慮機架的影響： 機架固定相當於減去 1 個構件的自由度，即減去 \\(3 \\cdot 1 = 3\\)。 於是，公式調整為僅考慮運動構件的自由度： \n \\[ DOF = 3(N - 1) - (2J_1 + J_2) \\] \n 這就是 Grübler 公式的最終形式。 六、為什麼要減去機架的自由度？ \n 機架固定後，其 3 個自由度（2 個平移 + 1 個旋轉）被約束。 這相當於從總自由度 \\(3N\\) 中減去機架的 \\(3\\)，因此使用 \\(3(N - 1)\\) 來表示運動構件的自由度。 應用到五連桿機構 \n 對於平面五連桿機構： \n \\(N = 5\\)（4 個運動連桿 + 1 個機架）。 \\(J_1 = 5\\)（5 個轉動副）。 \\(J_2 = 0\\)（無二自由度關節）。 代入公式： \n \\[ DOF = 3(5 - 1) - 2 \\cdot 5 - 0 = 3 \\cdot 4 - 10 = 12 - 10 = 2 \\] \n 自由度為 2，符合五連桿機構的特性。 推導的關鍵假設 \n 一、平面運動：公式假設機構在二維平面內運動，每個構件有 3 個自由度。 二、無冗餘約束：公式假設關節的約束是獨立的。如果機構有冗餘約束（例如平行四邊形結構），自由度可能需要進一步分析。 三、關節類型：公式適用於常見的轉動對、滑動對等，若有特殊關節，需重新計算約束。 特殊情況的考慮 \n 如果機構有冗餘約束（例如某些連桿的運動被重複限制），Grübler 公式可能給出不正確的自由度（例如負值或零），這表示機構可能過約束或需要特殊分析。 \n 對於五連桿機構，若結構為閉環且無冗餘約束，自由度通常為 2，這與實際應用（如繪圖機或機械手臂）一致。 \n \n \n \n', 'tags': '', 'url': '自由度.html'}, {'title': 'AI_plotter', 'text': '\n 已知一個平面五連桿繪圖機購得兩個馬達的中心座標位於 (0,0), (200,0), 四根連桿長度皆為 160mm, 若 plotter 繪圖的座標點為 (x,y), (0,0) 位置上的馬達其轉角從正向 X 軸起算, 以逆時針方向為正, 其轉動角度為 t1, 而(200,0) 位置上的馬達其轉角也是從正向 X 軸起算, 也是以逆時針方向為正, 其轉動角度為 t2, 請利用 Python sympy 推導出以 x, y 為輸入變數, 求四組 t1 與 t2 作為輸出的逆向運動方程式。 \n plotter_sympy_inverse_kinematics.py \n Plotter in Onshape \n \n link1 tip center: -24.436, 158.123, 9 (模型放大兩倍，並轉為 m (-0.048872, 0.316246)) pen center: 96.762, 262.578, -3 (模型放大兩倍，並轉為 m，(0.193524,\xa00.525156)) link3 tip center: 218.635, 158.911, 15 (模型放大兩倍，並轉為 m，(0.43727, 0.317822)) right motor center: 200, 0, 15 (模型放大兩倍，並轉為 m，(0.4, 0)) left motor center: 0,0,0 \n Webots 場景檔案: \n plotter_onshape_w3.7z \xa0(僅轉入馬達基座與左側 link1) \n plotter_onshape_w4.7z \xa0(僅轉入馬達基座、左側link1 與 link2) \n 採 matplotlib 模擬四種掃掠 20cmx20cm 正方形邊長的逆向運動學 Solutions: \n cad_demo_sym_formulation.py \n cad_demo_check_sym_sol.py \n Python math 格式: \n def t1_sol1(x, y): return 2 * cmath.atan((320*y - cmath.sqrt(-x**4 - 2*x**2*y**2 + 102400*x**2 - y**4 + 102400*y**2)) / (x**2 + 320*x + y**2))\ndef t2_sol1(x, y): return 2 * cmath.atan((320*y + cmath.sqrt(-x**4 + 800*x**3 - 2*x**2*y**2 - 137600*x**2 + 800*x*y**2 - 8960000*x - y**4 + 22400*y**2 + 2496000000)) / (x**2 - 720*x + y**2 + 104000))\n\n# Solution 2:\ndef t1_sol2(x, y): return 2 * cmath.atan((320*y - cmath.sqrt(-x**4 - 2*x**2*y**2 + 102400*x**2 - y**4 + 102400*y**2)) / (x**2 + 320*x + y**2))\ndef t2_sol2(x, y): return 2 * cmath.atan((320*y - cmath.sqrt(-x**4 + 800*x**3 - 2*x**2*y**2 - 137600*x**2 + 800*x*y**2 - 8960000*x - y**4 + 22400*y**2 + 2496000000)) / (x**2 - 720*x + y**2 + 104000))\n\n# Solution 3:\ndef t1_sol3(x, y): return 2 * cmath.atan((320*y + cmath.sqrt(-x**4 - 2*x**2*y**2 + 102400*x**2 - y**4 + 102400*y**2)) / (x**2 + 320*x + y**2))\ndef t2_sol3(x, y): return 2 * cmath.atan((320*y + cmath.sqrt(-x**4 + 800*x**3 - 2*x**2*y**2 - 137600*x**2 + 800*x*y**2 - 8960000*x - y**4 + 22400*y**2 + 2496000000)) / (x**2 - 720*x + y**2 + 104000))\n\n# Solution 4:\ndef t1_sol4(x, y): return 2 * cmath.atan((320*y + cmath.sqrt(-x**4 - 2*x**2*y**2 + 102400*x**2 - y**4 + 102400*y**2)) / (x**2 + 320*x + y**2))\ndef t2_sol4(x, y): return 2 * cmath.atan((320*y - cmath.sqrt(-x**4 + 800*x**3 - 2*x**2*y**2 - 137600*x**2 + 800*x*y**2 - 8960000*x - y**4 + 22400*y**2 + 2496000000)) / (x**2 - 720*x + y**2 + 104000)) \n \n mathjax 格式: \n JSolution 1 (同上列 math 格式 Solution 2): \\[ t_{1} = 2 \\operatorname{atan}{\\left(\\frac{320 y - \\sqrt{- x^{4} - 2 x^{2} y^{2} + 102400 x^{2} - y^{4} + 102400 y^{2}}}{x^{2} + 320 x + y^{2}} \\right)} \\] \\[ t_{2} = 2 \\operatorname{atan}{\\left(\\frac{320 y - \\sqrt{- x^{4} + 800 x^{3} - 2 x^{2} y^{2} - 137600 x^{2} + 800 x y^{2} - 8960000 x - y^{4} + 22400 y^{2} + 2496000000}}{x^{2} - 720 x + y^{2} + 104000} \\right)} \\] JSolution 2  (同上列 math 格式 Solution 1) : \\[ t_{1} = 2 \\operatorname{atan}{\\left(\\frac{320 y - \\sqrt{- x^{4} - 2 x^{2} y^{2} + 102400 x^{2} - y^{4} + 102400 y^{2}}}{x^{2} + 320 x + y^{2}} \\right)} \\] \\[ t_{2} = 2 \\operatorname{atan}{\\left(\\frac{320 y + \\sqrt{- x^{4} + 800 x^{3} - 2 x^{2} y^{2} - 137600 x^{2} + 800 x y^{2} - 8960000 x - y^{4} + 22400 y^{2} + 2496000000}}{x^{2} - 720 x + y^{2} + 104000} \\right)} \\] JSolution 3  (同上列 math 格式 Solution 4) : \\[ t_{1} = 2 \\operatorname{atan}{\\left(\\frac{320 y + \\sqrt{- x^{4} - 2 x^{2} y^{2} + 102400 x^{2} - y^{4} + 102400 y^{2}}}{x^{2} + 320 x + y^{2}} \\right)} \\] \\[ t_{2} = 2 \\operatorname{atan}{\\left(\\frac{320 y - \\sqrt{- x^{4} + 800 x^{3} - 2 x^{2} y^{2} - 137600 x^{2} + 800 x y^{2} - 8960000 x - y^{4} + 22400 y^{2} + 2496000000}}{x^{2} - 720 x + y^{2} + 104000} \\right)} \\] JSolution 4  (同上列 math 格式 Solution 3) : : \\[ t_{1} = 2 \\operatorname{atan}{\\left(\\frac{320 y + \\sqrt{- x^{4} - 2 x^{2} y^{2} + 102400 x^{2} - y^{4} + 102400 y^{2}}}{x^{2} + 320 x + y^{2}} \\right)} \\] \\[ t_{2} = 2 \\operatorname{atan}{\\left(\\frac{320 y + \\sqrt{- x^{4} + 800 x^{3} - 2 x^{2} y^{2} - 137600 x^{2} + 800 x y^{2} - 8960000 x - y^{4} + 22400 y^{2} + 2496000000}}{x^{2} - 720 x + y^{2} + 104000} \\right)} \\] \n 上列符號式求解(Symbolic Formulation)與圖形法求解進行比較: \n Plotter 到達點 (200, 230) 時的 t1 與 t2 角度（degree）: JSolution 3  (同上列 math 格式 Solution 4) : \n t1 = 66.72° \n t2 = 45.95° \n \n \n \n', 'tags': '', 'url': 'AI_plotter.html'}, {'title': 'P_onshape', 'text': '\n \n plotter_dimension_design_2.slvs \n webots_plotter_sympy.py \n webots_verification.py \n \n import cmath\nimport math\n\n# Solution 3:\ndef t1_sol3(x, y):\n    rad = 2.0 * cmath.atan(\n        (1280.0 * y + cmath.sqrt(\n            -4000000.0 * x**4\n            - 3200000.0 * x**3\n            - 8000000.0 * x**2 * y**2\n            - 4000000.0 * x**2 * y\n            + 178400.0 * x**2\n            - 3200000.0 * x * y**2\n            - 1600000.0 * x * y\n            + 327360.0 * x\n            - 4000000.0 * y**4\n            - 4000000.0 * y**3\n            - 181600.0 * y**2\n            + 409200.0 * y\n            + 125911.0\n        ) + 320.0) / (\n            2000.0 * x**2 + 2080.0 * x + 2000.0 * y**2 + 1000.0 * y + 461.0\n        )\n    )\n    return math.degrees(rad.real)\n\ndef t2_sol3(x, y):\n    rad = 2.0 * cmath.atan(\n        (1280.0 * y - cmath.sqrt(\n            -4000000.0 * x**4\n            + 3200000.0 * x**3\n            - 8000000.0 * x**2 * y**2\n            - 4000000.0 * x**2 * y\n            + 178400.0 * x**2\n            + 3200000.0 * x * y**2\n            + 1600000.0 * x * y\n            - 327360.0 * x\n            - 4000000.0 * y**4\n            - 4000000.0 * y**3\n            - 181600.0 * y**2\n            + 409200.0 * y\n            + 125911.0\n        ) + 320.0) / (\n            2000.0 * x**2 + 480.0 * x + 2000.0 * y**2 + 1000.0 * y - 51.0\n        )\n    )\n    return math.degrees(rad.real)\n\n# 測試\nprint(t1_sol3(0.2, 0.185), t2_sol3(0.2, 0.185))\n \n 利用右上方最遠的繪圖點進行上列 Solution 3 方程式查驗: \n plotter_dimension_design_2.slvs \n webots_ik_right_top_corner.py \xa0執行控制後機構模擬如下，之後可以修改此一程式透過 t1_ik(x, y) 與 t2_ik(x, y) 求得 plotter 繪圖點座標設置為繪圖區各點時的 t1 與 t2 馬達旋轉角度，其量測參考線為馬達右側的水平線作為起點，且逆時針方向為正。 \n plotter 零組件轉檔、 Webots 場景與控制器程式:\xa0 plotter_onshape_w5.7z ，請各組根據此參考資料，嘗試讓 plotter 可以在繪圖區 (目前為 0.4mx0.4m) 繪製任何線架構圖形。隨後可進一步加入提筆機構，並考量若進行實作原型時，該如何從 Webcam 取得的相片圖檔，轉換為可讓 plotter 繪製的線段圖形。 \n \n \n webots_check_sol3.py \n pythonw.exe -u "webots_check_sol3.py" --- Solution 3 at P(0.2, 0.185) --- t1 (Radians): (1.221335238965607+0j) t2 (Radians): (0.7473365120313953+0j) ------------------------------------------ t1 (Degrees): 69.9774 degrees t2 (Degrees): 42.8192 degrees \n \n', 'tags': '', 'url': 'P_onshape.html'}, {'title': 'P_webots', 'text': 'Webots 場景中的 hingejoint 是以機構的初始角度作為 0 度。 \n 轉入 Webots 的\xa0 Plotter in Onshape \xa0其機構初始設置為: \n \n 若以逆時針轉角為正， t1 必須反轉 8.78 度才能達到垂直的位置，而 t2 則必須正轉 6.69 度才能達到垂直的位置。 \n 若兩個馬達都以水平線作為 0 度，則處了考慮從垂直角度位置，還必須逆轉 90 度才能到達水平的零點轉角位置。 \n 此一角度座標定義，可以利用  webots_plotter_zero_degree.py \xa0控制程式，讓兩個馬達的轉角設置在水平位置。 \n \n plotter_onshape_w4.7z \n \n 兩種建立剛體的方法 url 給定 OBJ 或 STL 檔案所在相對位置: \n Solid  -  Shape  -  Mesh  - url \n CadShape  - url \n 利用 boundingObject 界定物件碰撞檢測範圍: \n boundingObject USE shape \n SolidReference  設定於 link3 端點，且參照 link4_solid，表示第四旋轉軸既位於 link3，同時也必須位於 link4，讓 Webots 透過此一 closed chain 約束條件，於系統方程式運算時，能夠模擬封閉連桿機構的運動。 \n \n 從\xa0 Plotter in Onshape \xa0以  STL  格式轉出後，利用\xa0 split_stl_to_obj_scale2_w_mtl.py ，以兩倍原始尺寸分割零件為  OBJ  格式後，轉進 Webots 建立第一階段的模擬場景: 僅 link1 轉動:\xa0 plotter_onshape_link1.7z \n', 'tags': '', 'url': 'P_webots.html'}, {'title': 'P_Control', 'text': 'Arduino  control two stepper motors \n 使用Python的pySerial模組進行序列通訊：連接電腦與Arduino和MicroPython \n Interfacing Webots through TCP/IP \n', 'tags': '', 'url': 'P_Control.html'}, {'title': 'P_BOM', 'text': '以下的 5 bar planar plotter 設計尺寸為 cm，希望自行以 3D 列印零件，請針對此機電設計提供詳細的所有零組件 BOM，其中包括規格以及說明採用原因，並且列出在台灣採購的單價: \n A 點座標 (0, 0) 為 5-bar planar plotter 的左邊馬達位置，其轉動角度以逆時針為正，轉角設為 t1，且從其右邊的水平線算起，E 點座標 (20, 0) 為右邊馬達位置，其轉動角度也是以逆時針為正，轉角設為 t2，也是從其右邊的水平線算起，AB 為 link1 長度為 20，BC 為 link2 長度為 27，CD 為 link3 長度為 27，DE 為 link4 長度為 20，C 點為 plotter 擺放位置。 請利用數值方法推導 def t1(cx, cy) 以及 t2(cx, cy)，其中 cx 為 plotter C 點的 x 座標，而 cy 則為 plotter C點的 y 座標。 \n 項目\t零件名稱       \t規格/建議型號                       \t數量  \t預計單價（TWD）\t單項總價（TWD）\t採購來源（台灣）                 \t採用原因                        \n1   \t步進馬達       \tNEMA 17 (1.8°, 42BYGHW208)        \t2     \t300            \t600            \t樂積木、露天拍賣、Maker stores   \t廣泛使用於 CNC/3D Printer，具備良好扭力\n2   \t馬達驅動板     \tA4988 / TMC2208                   \t2     \t75             \t150            \t樂積木、蝦皮、露天拍賣           \t控制步進馬達；TMC 較安靜              \n3   \t控制板         \tArduino Uno / Mega               \t1     \t375            \t375            \t樂積木、蝦皮                     \t易用、資源多                      \n4   \t板材（底座）    \t雷射切割壓克力 / 木板（20x30cm）    \t1     \t150            \t150            \tDIY材料行                        \t承載整個結構                      \n5   \t3D 列印連桿    \t長度 20cm / 27cm（自製）             \t4     \t40             \t160            \t自行列印                         \t根據連桿尺寸製作，輕巧                 \n6   \t銀球軸承       \t8mm 內徑（608ZZ）                  \t6     \t25             \t150            \t蝦皮                             \t降低摩擦，增加穩定性                  \n7   \tM3 螺絲/螺帽組 \tM3x20mm、M3x30mm                 \t1     \t50             \t50             \t蝦皮                             \t組裝連桿與軸承                     \n8   \t筆夾模組       \t3D列印零件 + 彈簧結構                 \t1     \t20             \t20             \t自製                             \t夾住筆尖，配合 Z 軸上下壓力             \n9   \t電源模組       \t12V 3A DC Adapter                \t1     \t200            \t200            \t樂積木 / 淘寶                    \t供電給馬達及控制板                   \n10  \t限位開關       \t機械型 Endstop                    \t3     \t25             \t75             \t樂積木                           \t做原點校準                       \n\n總計\t\t\t\t\t\t\t\t\t                                1930\n \n', 'tags': '', 'url': 'P_BOM.html'}, {'title': 'Openduck', 'text': 'Open Duck Mini  是一款模組化、開源的雙足仿生機器人平台，專為教育與研究設計，具備高自由度與低成本特性。 \n \n Openduck in Onshape \n https://github.com/apirrone/Open_Duck_reference_motion_generator \xa0 \n https://github.com/mdecycu/Open_Duck_Blender \xa0 \n openduck_frame.7z \xa0(parasolid in NX2312) \n Openduck in Solvespace: \n \n \n openduck_in_solvespace.7z \n \n openduck_w9.7z \n \n openduck_w10.7z \n \n Inverse Kinematic Solutions:\xa0 \n https://github.com/rpiRobotics/ik-geo \xa0 \n https://pypi.org/project/ik-geo/ \xa0 \n https://github.com/weigao95/yaik \xa0 \n https://github.com/rpiRobotics/rpi_general_robotics_toolbox_py \xa0 \n IK-Geo: Unified robot inverse kinematics using subproblem decomposition \n \n IK‑Geo 是一個針對 6 自由度全旋轉關節機器人（6R manipulator） 的逆運動學解法，採用「子問題分解法（subproblem decomposition）」的方式，把整個 IK 問題拆成六種幾何子問題（如圓與點、兩圓之交、圓與平面、圓與球、三圓交、四圓交）來逐步求解。 \n 對於某些特定的機構構型（例如有三個交會或平行軸線的 6R 機構），它能用閉式（closed-form）方式解出所有解，而無需數值搜尋。其他構型則可能退化為對一或兩個關節角做 1D 或 2D 搜索。 \n 作者宣稱對於許多常見工業 6R機器人（例如 UR5 等），IK-Geo 的速度能比 IKFast 快 40 倍以上。 \n IK-Geo 也具備處理奇異情況的能力（比如在解不存在時提供最小平方近似解或連續近似解）以增加解題穩健性。 \n 實作上，IK-Geo 提供 MATLAB、C++、Rust、Python 等多語言版本，並附有測試範例與效能比較。 \n IK-Geo 的主要特點是其採用幾何分解，加上部分搜尋混合的策略，以在效率與泛用性之間取得不錯的折衷。 \n \n 其他參考資料:\xa0 Automatic Geometric Decomposition for Analytical Inverse Kinematics \n \n 設計規格： \n \n 使用 12 顆  FeeTech STS3215  伺服馬達（7.4V，19kg·cm 扭矩）+ 2 顆  Miuzei 9g 輔助伺服 ，實現 14 個自由度（雙足腿部 10 DOF，頭頸 4 DOF），支援穩定步態、轉向與精確感測定位。 \n 機身採用 3D 列印（PLA 機身硬性結構/TPU 腳底軟性結構），尺寸約 42cm 高，總重約 1.0–1.3kg。 \n 控制單元為  Raspberry Pi Zero WH ，支援 Wi-Fi/Bluetooth 與模組化感測器擴充（如 IMU、攝影機）。電源為 7.4V 2S（2 顆  18650 電池 ），峰值電流 4–7A。提供  CAD 、韌體與原始碼，採開放授權，零件公開取得，BOM 總成本約$400 美元。 \n', 'tags': '', 'url': 'Openduck.html'}, {'title': 'O_Analysis', 'text': '\n OpenDuck Mini 的單腿結構（5DoF） \n Hip Yaw（髖部水平旋轉）- link1 長度即馬達旋轉中心至馬達底部的長度 0.03472m \n Hip Roll（髖部側擺）- link2 長度 0.06234m \n Hip Pitch（髖部前後擺）- link3 長度 0.07827m \n Knee Pitch（膝關節）- link4 長度 0.07827m \n Ankle Pitch（腳踝前後擺）- link5 長度 0.03132m \n Base -- Hip Yaw (rot_z) -- Hip Roll (rot_y) -- Hip Pitch (rot_x) -- Knee Pitch (rot_x) -- Ankle Pitch (rot_x) -- Foot (end-effector) \n 使用  ikpy  進行逆運動學運算: \n 導入必要的類別 (Chain, URDFLink, numpy)。 \n 定義機器人的幾何結構，創建一個 Chain 對象。 \n 定義目標位置或姿態 (target_position 或 target_frame)。 \n 呼叫 chain.inverse_kinematics() 即可獲得所需的關節角度。 \n openduck_ikpy1.py  (未移除警告)  openduck_ikpy2.py \xa0(已移除警告) \n Inverse Kinematics 程式將末端執行器移動到，以第一旋轉軸中心為座標原點的目標相對位置 [0.05,0.02,−0.15] (米)。 \n 冗餘度： 在這個特定的目標位置下，ikpy 求解器將大多數的工作分配給了 hip_yaw 和 hip_roll 兩個關節，而 hip_pitch、knee_pitch 和 ankle_pitch 三個俯仰角（理論上用來控制腿部彎曲和長度的主關節）都保持在它們的初始位置 0 rad。表示此目標位置僅靠髖關節的平移旋轉就能達到。 \n ikpy  的預設求解器 (基於梯度下降) 傾向於選擇最接近初始位置的解，由於您設置的初始位置都是 0 rad，因此它選擇了俯仰角接近 0 的解。 \n 關節名稱\xa0 \xa0 角度（弧度）\xa0 \xa0 角度（約略）\xa0 \xa0 備註 hip_yaw\xa0 \xa0 0.3805 rad\xa0 \xa0 ≈21.8∘\xa0 \xa0 髖關節偏航角 hip_roll\xa0 \xa0 −0.2837 rad\xa0 \xa0 ≈−16.3∘\xa0 \xa0 髖關節滾轉角 hip_pitch\xa0 \xa0 0.0000 rad\xa0 \xa0 0∘\xa0 \xa0 髖關節俯仰角 knee_pitch\xa0 \xa0 0.0000 rad\xa0 \xa0 0∘\xa0 \xa0 膝關節俯仰角 ankle_pitch\xa0 \xa0 0.0000 rad\xa0 \xa0 0∘\xa0 \xa0 踝關節俯仰角 \n \n 步態的角色： 步態 (Gait) 是一個動態、有時間序列的運動過程。它定義了 Openduck 如何按順序移動其雙足，其中涉及： \n \n 足端軌跡 (Foot Trajectory)： 腳尖在空中和地面上移動的路徑（通常是週期性的曲線，如正弦曲線或圓弧）。 \n 相位 (Phase)： 哪一條腿什麼時候在空中 (Swing Phase)，什麼時候在地上 (Stance Phase)。 \n 穩定性 (Stability)： 確保機器人的質心 (Center of Mass, CoM) 始終落在支撐多邊形內（靜態穩定性）或在動態上穩定。 \n \n \n 一、步態類型（Gait Type）選擇： \n 步態類別： \n ZMP-based gait（零力矩點）：適合穩定行走 \n CPG（Central Pattern Generator）：模仿生物神經節律 \n 步態庫（Gait Library）：預定義步態參數 \n 二、步態參數（Gait Parameters）包括： \n 步長（Step Length） \n 步高（Step Height） \n 步頻（Step Frequency） \n 支撐相時間（Support phase time） \n 擺動相時間（Swing phase time） \n 三、設定流程： \n 設計足端軌跡（在空間中畫出足的移動路徑） \n 採用拋物線形或貝茲曲線軌跡 \n 在某個時間內足端從 A 點擺到 B 點 \n 對每個時間點做 IK 求 joint angles \n 依據時間產生 joint command (例如 100Hz 控制迴圈，每 10ms 更新一次關節角度) \n 步驟: \n 建立單腿的 D-H 參數模型 \n 寫出 forward kinematics \n 用 symbolic 解反向運動學（或用數值法） \n 設計簡單的 foot trajectory（比如步高 5cm，步長 10cm） \n 實作 gait scheduler：分成支撐相與擺動相 \n 讓雙腿交錯控制（左腳擺動時右腳支撐） \n 步態規劃: \n https://github.com/ami-iit/bipedal-locomotion-framework \xa0 \n 若希望 Webots 結合上列 BLF 框架，在 Windows 環境中可以使用 conda 指令安裝: \n conda install conda-forge::bipedal-locomotion-framework-python \n 提問:\xa0Webots 模擬環境如何與 Bipedal Locomotion Framework (BLF, 即 bipedal‑locomotion‑framework) 結合應用? \n 提問:\xa0假如採用 https://github.com/aidudezzz/deepbots 與 webots 對 openduck 進行步態規劃學習, 該如何進行?\xa0 \n', 'tags': '', 'url': 'O_Analysis.html'}, {'title': 'O_Prompts', 'text': 'https://ikpy.readthedocs.io/en/latest/ \xa0 \n 針對運用  ikpy  的\xa0 openduck_ikpy2.py \xa0進行提問: \n 請詳細說明以下程式的設置原理:(接著貼上\xa0 openduck_ikpy2.py \xa0程式碼) \n 第一關節不能動是什麼意思? \n 所以第二關節是繞著 z 軸旋轉?\xa0而且距離第三關節有 0.03472m?\xa0第三關節是繞哪一軸旋轉? \n 請詳細說明一下 URDFLink( name="hip_roll", origin_translation=[0, 0, 0], origin_orientation=[0, 0, 0], rotation=[0, 1, 0] ) \n URDF 有沒有特殊意思? \n 假如採用  https://github.com/aidudezzz/deepbots、   https://github.com/Phylliade/ikpy  與 webots 對 openduck 進行步態規劃學習，該如何進行? 建議用來進行此類強化學習 (Reinforcement Learning) 的電腦硬體配備為何? \n RTX 1050 加上 intel Core i7 16GB 用於此類強化學習，配置夠用嗎? \n 對教育界有沒有免費的雲端強化學習資源可以使用? \n Openduck Webots 機電模型經過  Deepbots ， ikpy  的強化學習之後，得到甚麼結果? 後續該如何應用? \n \n 強化學習 (Reinforcement Learning) 訓練後得到的成果，是一個能接受輸入後，取得用來控制機器人動態表現的模型，這個模型包含了機器人如何決策和控制其運動的策略。這些策略通常以特定形式存儲，例如 神經網絡模型、Q 值表或其他適合問題的結構。當使用  Deepbots 、 ikpy  程式庫進行機器人步態學習時，將會取得以下結果： 一、訓練後的模型： \n 訓練的核心結果是策略模型，它將告訴機器人如何根據觀察到的狀態（例如機器人當前的位置、速度、加速度等）來決定行動（例如關節角度的控制）。這個模型通常是神經網絡或其他形式的決策函數。模型會學會最佳策略來達到預定目標，並避開障礙物或保持平衡。 \n 二、模型的存儲與提取： \n 在訓練過程中，模型通常會被保存在文件中，這樣可以在後續進行提取並應用到真實世界中。根據所使用的強化學習框架，模型的存儲格式會有所不同。以下是幾種情況： \n (1) 神經網絡模型： \n 訓練過程中，將深度神經網絡 (如 DQN、A3C、PPO 等算法) 來學習策略。這些神經網絡的權重 (weights) 和偏置 (bias) 會在訓練過程中不斷更新。 \n 訓練完成後，模型會被保存為一個模型檔案，通常以 .h5 (Keras)、.pth (PyTorch) 或 .ckpt (TensorFlow)等格式存儲。 \n 如何提取模型： \n 在  Deepbots  或 OpenAI Gym 等環境中，訓練後的模型可以使用程式庫所提供的 API 保存： \n model.save("trained_model.h5")  # Keras\ntorch.save(model.state_dict(), "trained_model.pth")  # PyTorch\n \n 之後，這些模型可以被加載並應用於新環境或真實世界的機器人： \n model = keras.models.load_model("trained_model.h5")  # Keras\nmodel.load_state_dict(torch.load("trained_model.pth"))  # PyTorch\n \n (2) 策略或 Q 值表： \n 如果使用 Q-learning 的傳統強化學習算法，訓練的結果通常是 Q 值表或策略表，它是機器人對每個可能的狀態-行為對應的期望回報值。 \n 這些表格可以保存在 CSV 文件、JSON 文件或其他格式中。它們通常是以狀態-行為對應的 Q 值或策略選擇的行為存儲。 \n 如何提取策略或 Q 值： \n 在 Q-learning 或 SARSA 等算法中，訓練後的 Q 值表可以直接保存： \n import json\nwith open("q_table.json", "w") as f:\n    json.dump(q_table, f)\n \n 然後可以通過載入 Q 表來進行決策： \n with open("q_table.json", "r") as f:\n    q_table = json.load(f)\n \n (3) 策略梯度方法的策略模型： \n 如果使用的是策略梯度方法 (如 A3C、PPO 等)，訓練的結果通常是策略模型，它將從當前狀態生成對應的行為分佈(或確定行為)。 \n 這些模型通常是神經網路，用於從環境中觀察的狀態生成行為或動作。 \n 如何提取策略： \n 訓練後，策略模型也可以像其他神經網路一樣保存： \n model.save("policy_model.h5")  # Keras\n \n 加載策略模型後，當機器人需要執行動作時，可以通過這個模型來選擇對應的行為： \n policy_model = keras.models.load_model("policy_model.h5")\naction = policy_model.predict(current_state)\n \n 三、 如何在後續應用中使用訓練模型： \n (1) 將模型應用到真實世界機器人： \n 在 Webots 中進行訓練後，訓練好的模型可以用來控制真實機器人的行為。這通常需要將模型嵌入到機器人的控制系統中。這可以通過以下步驟實現： \n 步驟1：將訓練好的模型加載到機器人控制程式中 (例如使用 TensorFlow 或 PyTorch 等框架)。 \n 步驟2：從機器人的感測器 (如相機、IMU、加速度計等) 獲取當前狀態，並將其傳遞到訓練過的模型中。 \n 步驟3：模型根據當前狀態生成對應的控制指令 (例如關節角度、步伐大小等)。 \n 步驟4：將控制指令發送到機器人硬體進行執行。 \n 具體例子： \n 假設使用 PPO 算法訓練機器人的行走策略，訓練後的模型可以加載並應用到 Webots 模擬場景中： \n # 假設用 Keras 訓練過的 PPO 策略模型\nmodel = keras.models.load_model("ppo_model.h5")\n\n# 獲取當前狀態（例如機器人的位置、速度等）\ncurrent_state = get_robot_state()\n\n# 通過模型預測行動\naction = model.predict(current_state)\n\n# 發送控制命令到 Webots\napply_action_to_robot(action)\n \n (2) 實時控制與微調： \n 訓練後的模型還可以在真實世界運行中進行微調，這可以幫助模型適應現實環境中的細微差異 (例如摩擦、感測器噪聲等)。微調的過程可能涉及到： \n 強化學習的線上學習：機器人在實際環境中執行時，根據結果 (如成功步行距離、穩定性等)進行即時調整。 \n 自適應控制：根據真實世界的回饋進行控制策略的更新，也可以基於經驗進行調整。 \n 四、後續應用： \n 訓練後的模型除了用於機器人的即時控制外，還可以應用於以下領域： \n 模擬中進行更多訓練：可以在訓練過程中使用模型生成的數據進行後續的強化學習。 \n 跨平台應用：訓練後的模型可以從 Webots 模擬遷移到不同的機器人平臺，如移動平台、機械臂等。 \n 步態最佳化：在新環境中可以進行步態最佳化，讓機器人自動適應不同的場地。', 'tags': '', 'url': 'O_Prompts.html'}, {'title': 'O_BOM', 'text': '請針對自組一隻  https://github.com/apirrone/Open_Duck_Mini  所需要的詳細機電零組件 BOM, 其中包括零件名稱，規格，數列，單價，單項總價, 台灣採購來源, 採用原因等欄位, 最後一列再列出整體總價。 \n 序號\t類別\t\t零件名稱\t\t規格 / 型號 / 備註\t\t\t\t\t數量\t單價(TWD)\t小計(TWD)\t採購來源\t\t\t\t採用理由\n1\t控制\t\tRaspberry Pi Zero 2W\t1GHz CPU / WiFi / BT / GPIO\t\t\t1\t467\t\t467\t\t樂積木、台灣 Maker 通路\t輕巧嵌入式 Linux 控制核心\n2\t控制\t\tMicroSD 卡\t\t32 GB UHS-I (Class 10)\t\t\t\t1\t150\t\t150\t\t記憶卡通路\t\t\t\t作業系統與資料儲存\n3\t電源\t\t鋰電池組\t\t2S / 7.4V LiPo, ≥2000mAh\t\t\t\t1\t300\t\t300\t\t模型電池店、RC通路\t\t\t機器人主要動力來源\n4\t電源\t\t保護板 / BMS\t\t過充/過放/過流保護 2S\t\t\t\t\t1\t120\t\t120\t\t電子零件店\t\t\t\t保護鋰電池安全運作\n5\t電源\t\tDC-DC 降壓模組\t\t輸入 7.4V → 輸出 5V/3A\t\t\t\t1\t80\t\t80\t\t樂積木、蝦皮等\t\t\t\tRaspberry Pi 電源穩壓\n6\t驅動器\t\tBAM 關節驅動器\t\tRhoban BAM mini 或同級（每關節一顆）\t12\t1200\t\t14400\t\t國外代理（Rhoban）\t\t\t高整合度，適用於輕型機器人關節\n7\t感測器\t\tIMU 模組\t\tMPU-9250 / BNO055 等 9軸模組\t\t\t1\t250\t\t250\t\t感測器通路、樂積木\t\t\t測姿態與角度\n8\t感測器\t\t電流感測器\t\tINA219 / ACS712 模組\t\t\t\t\t2\t80\t\t160\t\t電子零件通路\t\t\t\t偵測耗電/異常動作\n9\t感測器\t\t限位開關\t\t微型機械型，常閉\t\t\t\t\t4\t25\t\t100\t\t電子零件行\t\t\t\t做歸零 / 原點偵測\n10\t機構\t\t3D 列印件\t\tPLA（身體）、TPU（腳底）\t\t\t\t1\t300\t\t300\t\t自列或代印\t\t\t\t\t機構主體、自定義設計\n11\t機構\t\t軸承\t\t\t如 5×11×4mm（視設計）\t\t\t\t10\t30\t\t300\t\t五金行、蝦皮、軸承商\t\t\t降低轉動摩擦、延長壽命\n12\t機構\t\t鋼軸 / 鉸軸\t\tΦ3mm / Φ4mm 不鏽鋼或碳鋼軸\t\t\t6\t20\t\t120\t\t模型五金店\t\t\t\t\t關節或連桿軸心用\n13\t機構\t\t螺絲螺帽\t\tM2~M3 不等規格\t\t\t\t\t1組\t50\t\t50\t\t螺絲材料包、蝦皮\t\t\t\t結構固定用\n14\t連接\t\t線材排線\t\t杜邦線 / JST / AWG22-26\t\t\t\t1組\t100\t\t100\t\t電子材料行\t\t\t\t訊號/電源連接\n15\t選配\t\tOLED 顯示模組\t\t0.96 吋 I2C OLED\t\t\t\t\t1\t120\t\t120\t\t模組供應商\t\t\t\t狀態顯示/除錯介面\n16\t選配\t\t無線模組\t\tESP32 / nRF24L01+ 模組\t\t\t\t1\t150\t\t150\t\t樂積木、模組商\t\t\t\t遠端調試/無線通信\n17\t外觀\t\t裝飾殼件\t\t3D列印或壓克力蓋板\t\t\t\t\t若干\t100\t\t100\t\t自印/壓克力材料行\t\t\t外觀美化/防塵\n\n總計\t\t\t\t\t\t\t\t\t\t\t\t-\t-\t\t16,317\t\t-\n', 'tags': '', 'url': 'O_BOM.html'}, {'title': 'O_IK', 'text': "https://github.com/Phylliade/ikpy \xa0 \n https://la.disneyresearch.com/wp-content/uploads/BD_X_paper.pdf \xa0 \n \n https://github.com/pollen-robotics/Open_Duck_Blender \n https://la.disneyresearch.com/wp-content/uploads/Development-of-a-Bipedal-Robot-that-Walks-Like-an-Animation-Character-Paper.pdf \xa0 \n 5R robot foot inverse kinematics involves calculating the joint angles needed to place a robot's foot in a desired position and orientation, which is a complex problem solved through various methods like analytical solutions, geometric approaches, and computational algorithms. \xa0 \n These methods often involve using the robot's kinematic model, such as the \xa0 Denavit-Hartenberg (D-H) model , \xa0 to derive a system of equations that can then be solved for the joint angles. \xa0 Advanced techniques like \xa0 screw theory \xa0 or \xa0 Gröbner bases \xa0 are used to handle complex robot configurations and provide efficient, accurate, and singularity-free solutions. \xa0 \n https://github.com/rpiRobotics/ik-geo \xa0 \n https://alefram.github.io/posts/Basic-inverse-kinematics-in-Mujoco \xa0 \n https://github.com/petercorke/robotics-toolbox-python \xa0", 'tags': '', 'url': 'O_IK.html'}, {'title': 'Webots', 'text': '如何將 MCAD(Mechanical Computer Aided Design) 組立檔案轉為 Webots 場景 .wbt \n URDF(Unified Robot Description Format): \n https://wiki.ros.org/urdf/XML \xa0 \n 將\xa0 https://github.com/Rhoban/onshape-to-robot \xa0改寫為 NX-to-robot \n Converter: \n https://github.com/cyberbotics/webots/tree/master/scripts/converter \xa0 \n https://github.com/cyberbotics/urdf2webots \xa0 \n https://github.com/cyberbotics/webots/tree/master/resources/osm_importer \xa0 \n https://suke.uclalemur.org/pcbot/lab2/webots_import/ \xa0 \n PR: \n Mesh node \n 利用  https://mermaid.js.org/ \xa0建立 Webots 場景節點流程圖: \n link0.html \n <!DOCTYPE html>\n<html lang="en">\n  <script type="module">\n    import mermaid from \'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs\';\n    mermaid.initialize({ startOnLoad: true });\n  </script>\n</head>\n<body>\n  <div class="mermaid">\nflowchart TD\n    %% link0\n    subgraph L0[link0]\n    direction TB\n\n    %% 頂層節點, Plotter 為物件名稱, 中括號內為內置字串\n    Plotter[Robot]\n\n    %% 三個主要分支\n    Plotter --> Robot物理節點[physics]\n    Robot物理節點 --> 物理節點[NULL]\n\n    Plotter --> Robot_boundingObject[boundingObject]\n    Robot_boundingObject --> UseLink0[NULL]\n\n    Plotter --> Children[children]\n    Children --> DefLink0[DEF Link_0 Shape]\n    Children --> HingeJoint[HingeJoint]  \n    DefLink0 -.->UseLink0\n\n    HingeJoint --> Devices[devices]\n    Devices --> Motor[RotationalMotor<br/>name: \'motor0\']\n\n    HingeJoint --> JointParams[jointparameters]\n    JointParams --> HingeParams[HingeJointParameters]\n\n    HingeJoint --> EndPoint[endPoint]\n    EndPoint --> Solid[DEF link1 Solid]\n\n    %% 新增三個節點並連接 Solid\n    Solid --> Physics2[physics]\n    Solid --> Bounding2[boundingobject]\n    Solid --> Children2[children]\n    end\n  </div>\n</body>\n</html>\n \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Mermaid', 'text': '將 gist 上的 mermaid 流程圖顯示在頁面: \n <script type="module">// <![CDATA[\nimport mermaid from \'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs\';\n\nasync function loadMermaidFromGist() {\n  const res = await fetch(\'https://gist.githubusercontent.com/mdecycu/ca89be74dfb4daec472df7c31cc935fb/raw/7fa1c03f621614134842daf17647f0a86ff581b7/cad1\');\n  const code = await res.text();\n\n  const container = document.getElementById(\'cad1\');\n  container.className = \'mermaid\';        // apply mermaid styling\n  container.textContent = code;           // insert Mermaid diagram code as text\n\n  // Initialize Mermaid\n  mermaid.initialize({ startOnLoad: false });\n  mermaid.init(undefined, container);     // render only this container\n}\n\nloadMermaidFromGist();\n// ]]></script> \n \n \n', 'tags': '', 'url': 'Mermaid.html'}, {'title': 'Rocket', 'text': '\n osm importer   OSM \n \n \n \n https://github.com/mathworks/Modeling-TVCd-Rocket-in-Simulink \xa0', 'tags': '', 'url': 'Rocket.html'}]};